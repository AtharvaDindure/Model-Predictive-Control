from gekko import GEKKO
import numpy as np
m = GEKKO()  # GEKKO model instance
# Matrices and vectors
Q = np.array([[0, 0, 0], [0, 0, 0], [0, 0, 2]])
R = 2
# Cost matrix G (20x20 diagonal with some 2s)
G = np.zeros((20, 20))
for i in range(2, 20, 3):
    G[i, i] = 2
# Inequality constraints
P = np.array([
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1]
])
q = np.ones((10, 1))
# Equality constraint matrix A (15x20)
A = np.array([
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],
    [0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,-0.1,0,0,0,0],
    [0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0],
    [0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0.1,-0.5,2,0,0,1,0,0,0,0,0,0,0,0,0,0,-0.1,0,0,0],
    [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,-1,0,0],
    [0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0.1,-0.5,2,0,0,1,0,0,0,0,0,0,0,0,-0.1,0,0],
    [0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,-1,0],
    [0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0.1,-0.5,2,0,0,1,0,0,0,0,0,0,-0.1,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,-1],
    [0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0.1,-0.5,2,0,0,1,0,0,0,0,-0.1]
])
b = np.array([[0],[1],[2],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0],[0]])
# Decision variables
z = m.Array(m.Var, 20)
# Objective function: z^T G z
m.Obj(0.5 * sum([z[i] * G[i, j] * z[j] for i in range(20) for j in range(20)]))
# Equality constraints: A @ z == b
for i in range(15):
    m.Equation(sum([A[i, j] * z[j] for j in range(20)]) == b[i, 0])
# Inequality constraints: P @ z <= q
for i in range(10):
    m.Equation(sum([P[i, j] * z[j] for j in range(20)]) <= q[i, 0])
# Solve the optimization
m.solve(disp=False)
# Output result
print('optimal x =', [zi.value[0] for zi in z])
print('optimal weight =', m.options.objfcnval)
